# Copyright 2009 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

#go:generate go run makeisprint.go -output isprint.go

# package strconv

import strutils
import unicode

import utf8
import isprint

const lowerhex = "0123456789abcdef"

const ErrSyntax* = "Syntax Error"

# const 
#   RuneError* = 0xFFFD     # the "error" Rune or "Unicode replacement character"
#   RuneSelf*  = 0x80         # characters below Runeself are represented as themselves in a single byte.
#   MaxRune*   = 0x0010FFFF # Maximum valid Unicode code point.
#   UTFMax*    = 4            # maximum number of bytes of a UTF-8 encoded Unicode character.

converter toInt(x: char): int = result = ord(x)
converter toChar(x: int): char = result = chr(x)  


proc IsPrint*(r: rune): bool {.gcsafe.}
proc isInGraphicList*(r: rune): bool {.gcsafe.}


proc appendEscapedRune(buf: var string, r: rune, width: int, quote: char, ASCIIonly, graphicOnly: bool): string =
  var r = r
  var runeTmp = " ".repeat(UTFMax)
  if r == rune(quote) or r == '\\'.rune:  # always backslashed
    add(buf, '\\')
    add(buf, char(r))
    return buf
  
  if ASCIIonly:
    if r < RuneSelf and IsPrint(r):
      add(buf, char(r))
      return buf
  elif IsPrint(r) or graphicOnly and isInGraphicList(r):
    let n = EncodeRune(runeTmp, r)
    add(buf, runeTmp[0..n-1])
    return buf
   
  if r < 128:
    case char(r)
    of '\a':
      add(buf, r"\a")
    of '\b':
      add(buf, r"\b")
    of '\f':
      add(buf, r"\f")
    of '\L':
      add(buf, r"\n")
    of '\r':
      add(buf, r"\r")
    of '\t':
      add(buf, r"\t")
    of '\v':
      add(buf, r"\v")
    else:
      if char(r) < ' ':
        add(buf, r"\x")
        add(buf, lowerhex[int8(r) shr 4])
        add(buf, lowerhex[int8(r) and 0xF])
  else:
    if r > MaxRune:
      r = rune(0xFFFD)
      add(buf, r"\u")
      for s in countDown(12, 0, 4):
        add(buf, lowerhex[r shr uint(s) and 0xF])
    elif r < 0x10000:
      add(buf, r"\u")
      for s in countDown(12, 0, 4):
        add(buf, lowerhex[r shr uint(s) and 0xF])
    else:
      add(buf, r"\U")
      for s in countDown(28, 0, 4):
      # for s := 28; s >= 0; s -= 4 {
        add(buf, lowerhex[r shr uint(s) and 0xF])
  return buf


proc appendQuotedWith(buf: var string, s: string, quote: char, ASCIIonly, graphicOnly: bool): string =
  add(buf, quote)
  var width = 0
  var s = s
  while len(s) > 0:
  # for width := 0; len(s) > 0; s = s[width:] {
    var r = rune(runeAt(s, 0))
    width = 1
    if r >= RuneSelf:
      (r, width) = utf8.DecodeRuneInString(s)
    if width == 1 and r == RuneError:
      add(buf, r"\x")
      add(buf, $lowerhex[int(s[0].uint8 shr 4)])
      add(buf, $lowerhex[int(s[0].uint8 and 0xF)])
      s = s[width..^1]
      continue
    
    buf = appendEscapedRune(buf, r, width, quote, ASCIIonly, graphicOnly)
    s = s[width..^1]

  add(buf, quote)
  return buf



proc quoteWith(s: string, quote: char, ASCIIonly, graphicOnly: bool): string =
#  var buf = " ".repeat(int(3*len(s) / 2))
  var buf = ""
  return appendQuotedWith(buf, s, quote, ASCIIonly, graphicOnly)


proc appendQuotedRuneWith(buf: var string, r: rune, quote: char, ASCIIonly, graphicOnly: bool): string =
  var r = r
  add(buf, quote)

  if `not`(ValidRune(r)):
    r = RuneError
  
  buf = appendEscapedRune(buf, r, RuneLen(r), quote, ASCIIonly, graphicOnly)
  add(buf, quote)
  return buf


proc quoteRuneWith(r: rune, quote: char, ASCIIonly, graphicOnly: bool): string =
  var buf = ""
  return appendQuotedRuneWith(buf, r, quote, ASCIIonly, graphicOnly)


proc Quote*(s: string): string =
  ## Quote returns a double-quoted Go string literal representing s. The
  ## returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
  ## control characters and non-printable characters as defined by
  ## IsPrint.
  var s = s
  return quoteWith(s, '"', false, false)


proc AppendQuote*(dst: var string, s: string): string =
  ## AppendQuote appends a double-quoted Go string literal representing s,
  ## as generated by Quote, to dst and returns the extended buffer.
  return appendQuotedWith(dst, s, '"', false, false)


proc QuoteToASCII*(s: string): string =
  ## QuoteToASCII returns a double-quoted Go string literal representing s.
  ## The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
  ## non-ASCII characters and non-printable characters as defined by IsPrint.
  return quoteWith(s, '"', true, false)


proc AppendQuoteToASCII*(dst: var string, s: string): string =
  ## AppendQuoteToASCII appends a double-quoted Go string literal representing s,
  ## as generated by QuoteToASCII, to dst and returns the extended buffer.
  return appendQuotedWith(dst, s, '"', true, false)


proc QuoteToGraphic*(s: string): string =
  ## QuoteToGraphic returns a double-quoted Go string literal representing s.
  ## The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
  ## non-ASCII characters and non-printable characters as defined by IsGraphic.
  var s = s
  return quoteWith(s, '"', false, true)


proc AppendQuoteToGraphic*(dst: var string, s: string): string =
  ## AppendQuoteToGraphic appends a double-quoted Go string literal representing s,
  ## as generated by QuoteToGraphic, to dst and returns the extended buffer.
  return appendQuotedWith(dst, s, '"', false, true)


proc QuoteRune*(r: rune): string =
  ## QuoteRune returns a single-quoted Go character literal representing the
  ## rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100)
  ## for control characters and non-printable characters as defined by IsPrint.  
  return quoteRuneWith(r, '\'', false, false)


proc AppendQuoteRune*(dst: var string, r: rune): string =
  ## AppendQuoteRune appends a single-quoted Go character literal representing the rune,
  ## as generated by QuoteRune, to dst and returns the extended buffer.
  return appendQuotedRuneWith(dst, r, '\'', false, false)


proc QuoteRuneToASCII*(r: rune): string =
  ## QuoteRuneToASCII returns a single-quoted Go character literal representing
  ## the rune. The returned string uses Go escape sequences (\t, \n, \xFF,
  ## \u0100) for non-ASCII characters and non-printable characters as defined
  ## by IsPrint.
  return quoteRuneWith(r, '\'', true, false)


proc AppendQuoteRuneToASCII*(dst: var string, r: rune): string =
  ## AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,
  ## as generated by QuoteRuneToASCII, to dst and returns the extended buffer.
  return appendQuotedRuneWith(dst, r, '\'', true, false)


proc QuoteRuneToGraphic*(r: rune): string =
  ## QuoteRuneToGraphic returns a single-quoted Go character literal representing
  ## the rune. The returned string uses Go escape sequences (\t, \n, \xFF,
  ## \u0100) for non-ASCII characters and non-printable characters as defined
  ## by IsGraphic.
  return quoteRuneWith(r, '\'', false, true)


proc AppendQuoteRuneToGraphic*(dst: var string, r: rune): string =
  ## AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,
  ## as generated by QuoteRuneToGraphic, to dst and returns the extended buffer.
  return appendQuotedRuneWith(dst, r, '\'', false, true)


proc CanBackquote*(s: string): bool =
  ## CanBackquote reports whether the string s can be represented
  ## unchanged as a single-line backquoted string without control
  ## characters other than tab.
  var s = s
  while len(s) > 0:
    var (r, wid) = DecodeRuneInString(s)
    s = s[wid..^1]
    if wid > 1:
      if r == rune(runeAt("\ufeff", 0)):
        return false # BOMs are invisible and should not be quoted.
      continue # All other multibyte runes are correctly encoded and assumed printable.
    
    if r == RuneError:
      return false
    
    if (char(r) < ' ' and char(r) != '\t') or char(r) == '`' or char(r) == '\u007F':
      return false
    
  return true


proc unhex(b: char): tuple[v: rune, ok: bool] =
  let c = b

  if '0' <= c and c <= '9':
    return (rune(c - '0'), true)
  if 'a' <= c and c <= 'f':
    return (rune(c - 'a' + 10), true)
  if 'A' <= c and c <= 'F':
    return (rune(c - 'A' + 10), true)
  return


proc UnquoteChar(s: string, quote: char): tuple[value: rune, multibyte: bool, tail: string, err: string] =
  ## UnquoteChar decodes the first character or byte in the escaped string
  ## or character literal represented by the string s.
  ## It returns four values:
  ##
  ##  1) value, the decoded Unicode code point or byte value;
  ##  2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;
  ##  3) tail, the remainder of the string after the character; and
  ##  4) an error that will be nil if the character is syntactically valid.
  ##
  ## The second argument, quote, specifies the type of literal being parsed
  ## and therefore which escaped quote character is permitted.
  ## If set to a single quote, it permits the sequence \' and disallows unescaped '.
  ## If set to a double quote, it permits \" and disallows unescaped ".
  ## If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.

  var s = s
  # easy cases
  var c = s[0]

  if c == quote and (quote == '\'' or quote == '"'):
    result.err = ErrSyntax
    return
  if int(c) >= RuneSelf:
    let (r, size) = utf8.DecodeRuneInString(s)
    return (r, true, s[size..^1], nil)
  if c != '\\':
    return (rune(s[0]), false, s[1..^1], nil)
  

  # hard case: c is backslash
  if len(s) <= 1:
    result.err = ErrSyntax
    return
  
  c = s[1]
  s = s[2..^1]

  block mainswitch:
    case c
    of 'a':
      result.value = rune('\a')
    of 'b':
      result.value = rune('\b')
    of 'f':
      result.value = rune('\f')
    of 'n':
      result.value = rune('\L')
    of 'r':
      result.value = rune('\r')
    of 't':
      result.value = rune('\t')
    of 'v':
      result.value = rune('\v')
    of 'x', 'u', 'U':
      var n = 0
      case c
      of 'x':
        n = 2
      of 'u':
        n = 4
      of 'U':
        n = 8
      else:
        discard
      var v: rune
      if len(s) < n:
        result.err = ErrSyntax
        return
      
      for j in countUp(0, n - 1):
      # for j := 0; j < n; j++ {
        let (x, ok) = unhex(s[j])
        if not ok:
          result.err = ErrSyntax
          return
        
        v = v shl 4 or x
      
      s = s[n..^1]
      if c == 'x':
        # single-byte string, possibly not UTF-8
        result.value = v
        break
      
      if v > utf8.MaxRune:
        result.err = ErrSyntax
        return
      
      result.value = v
      result.multibyte = true
    of '0', '1', '2', '3', '4', '5', '6', '7':
      var v = rune(c) - '0'
      if len(s) < 2:
        result.err = ErrSyntax
        return
      
      for j in countUp(0, 1):
      # for j := 0; j < 2; j++ { // one digit already; two more
        let x = s[j] - '0'
        if x < 0 or x > 7:
          result.err = ErrSyntax
          return
        
        v = (v shl 3) or x
      
      s = s[2..^1]
      if v > 255:
        result.err = ErrSyntax
        return
      
      result.value = rune(v)
    of '\\':
      result.value = rune('\\')
    of '\'', '"':
      if c != quote:
        result.err = ErrSyntax
        return
      
      result.value = rune(c)
    else:
      result.err = ErrSyntax
      return
  
  result.tail = s
  return


proc contains(s: string, c: char): bool =
  ## contains reports whether the string contains the byte c.
  for i in countUp(0, len(s) - 1):
  # for i := 0; i < len(s); i++ {
    if s[i] == c:
      return true
  return false


proc Unquote*(s: string): (string, string) =
  ## Unquote interprets s as a single-quoted, double-quoted,
  ## or backquoted Go string literal, returning the string value
  ## that s quotes.  (If s is single-quoted, it would be a Go
  ## character literal; Unquote returns the corresponding
  ## one-character string.)
  var s = s

  var n = len(s)
  if n < 2:
    return ("", ErrSyntax)
  
  let quote = s[0]
  if quote != s[n-1]:
    return ("", ErrSyntax)
  
  s = s[1 .. n-2]

  if quote == '`':
    if contains(s, '`'):
      return ("", ErrSyntax)
    
    if contains(s, '\r'):
      var buf = ""
      for i in countUp(0, len(s) - 1):
      #for i := 0; i < len(s); i++ {
        if s[i] != '\r':
          add(buf, s[i])
        
      return (buf, nil)
    
    return (s, nil)
  
  if quote != '"' and quote != '\'':
    return ("", ErrSyntax)
  
  if contains(s, '\L'):
    return ("", ErrSyntax)
  
  # Is it trivial?  Avoid allocation.
  if not contains(s, '\\') and not contains(s, quote):
    if quote == '"':
      return (s, nil)
    elif quote == '\'':
      let (r, size) = utf8.DecodeRuneInString(s)
      if size == len(s) and (r != utf8.RuneError or size != 1):
        return (s, nil)

  #var runeTmp = " ".repeat(utf8.UTFMax)
  var runeTmp = "    "
  #var buf = " ".repeat(3 * len(s) div 2) # Try to avoid more allocations.
  var buf = ""
  while len(s) > 0:
    let (c, multibyte, ss, err) = UnquoteChar(s, quote)
    if err != nil:
      return ("", err)
    
    s = ss
    if c < utf8.RuneSelf or not multibyte:
      add(buf, char(c))
    else:
      n = utf8.EncodeRune(runeTmp, c)
      add(buf, runeTmp.strip())
    
    if quote == '\'' and len(s) != 0:
      # single-quoted must be single character
      return ("", ErrSyntax)
    
  return (buf, nil)



proc bsearch16(a: openArray[uint16], x: uint16): int =
  ## bsearch16 returns the smallest i such that a[i] >= x.
  ## If there is no such i, bsearch16 returns len(a).

  var (i, j) = (0, len(a))
  while i < j:
    let h = i + (j-i) div 2
    if a[h] < x:
      i = h + 1
    else:
      j = h
  return i


proc bsearch32(a: openArray[uint32], x: uint32): int =
  ## bsearch32 returns the smallest i such that a[i] >= x.
  ## If there is no such i, bsearch32 returns len(a).

  var (i, j) = (0, len(a))
  while i < j:
    let h = i + (j-i) div 2
    if a[h] < x:
      i = h + 1
    else:
      j = h
  return i


# TODO: IsPrint is a local implementation of unicode.IsPrint, verified by the tests
# to give the same answer. It allows this package not to depend on unicode,
# and therefore not pull in all the Unicode tables. If the linker were better
# at tossing unused tables, we could get rid of this implementation.
# That would be nice.

proc IsPrint*(r: rune): bool =
  ## IsPrint reports whether the rune is defined as printable by Go, with
  ## the same definition as unicode.IsPrint: letters, numbers, punctuation,
  ## symbols and ASCII space.
  var r = r
  # Fast check for Latin-1
  if r <= 0xFF:
    if 0x20 <= r and r <= 0x7E:
      # All the ASCII is printable from space through DEL-1.
      return true
    
    if 0xA1 <= r and r <= 0xFF:
      # Similarly for ¡ through ÿ...
      return r != 0xAD # ...except for the bizarre soft hyphen.
    
    return false

  # Same algorithm, either on uint16 or uint32 value.
  # First, find first i such that isPrint[i] >= x.
  # This is the index of either the start or end of a pair that might span x.
  # The start is even (isPrint[i&^1]) and the end is odd (isPrint[i|1]).
  # If we find x in a range, make sure x is not in isNotPrint list.

  if 0 <= r and r < (1 shl 16):
    let (rr, isPrint, isNotPrint) = (uint16(r), isPrint16, isNotPrint16)
    let i = bsearch16(isPrint, rr)
    if i >= len(isPrint) or rr < isPrint[i and `not`(1)] or isPrint[i or 1] < rr:
      return false
    
    let j = bsearch16(isNotPrint, rr)
    return j >= len(isNotPrint) or isNotPrint[j] != rr
  

  let (rr, isPrint, isNotPrint) = (uint32(r), isPrint32, isNotPrint32)
  let i = bsearch32(isPrint, rr)
  if i >= len(isPrint) or rr < isPrint[i and `not`(1)] or isPrint[i or 1] < rr:
    return false
  
  if r >= 0x20000:
    return true
  
  r -= rune(0x10000)
  let j = bsearch16(isNotPrint, uint16(r))
  return j >= len(isNotPrint) or isNotPrint[j] != uint16(r)


proc IsGraphic*(r: rune): bool =
  ## IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such
  ## characters include letters, marks, numbers, punctuation, symbols, and
  ## spaces, from categories L, M, N, P, S, and Zs.

  if IsPrint(r):
    return true
  
  return isInGraphicList(r)


proc isInGraphicList*(r: rune): bool =
  ## isInGraphicList reports whether the rune is in the isGraphic list. This separation
  ## from IsGraphic allows quoteWith to avoid two calls to IsPrint.
  ## Should be called only if IsPrint fails.

  # We know r must fit in 16 bits - see makeisprint.go.
  if r > 0xFFFF:
    return false
  
  let rr = uint16(r)
  let i = bsearch16(isGraphic, rr)
  return i < len(isGraphic) and rr == isGraphic[i]

